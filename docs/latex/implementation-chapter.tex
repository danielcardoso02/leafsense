\chapter{Implementation}

\setlength{\parindent}{0pt}
\hspace{1cm}{This chapter details the technical realization of the LeafSense platform. The implementation strategy moved beyond simple prototyping to establish a robust C++ Embedded Architecture, optimizing for the strict timing requirements of the sensor control loops and seamless integration with the Qt5 graphical framework.}

\setlength{\parindent}{0pt}
\hspace{1cm}{The system is built upon a custom Linux distribution generated via Buildroot 2025.08, specifically tailored for the Raspberry Pi 4 Model B.}

\subsection*{Implementation Evolution Note}

\setlength{\parindent}{0pt}
\hspace{1cm}{\textit{It is important to note that the implementation described in this chapter evolved beyond the original design specification. During the development and testing phases, several enhancements were made to address practical challenges encountered during real-world deployment:}}

\begin{itemize}
    \item \textbf{Out-of-Distribution Detection:} The ML pipeline was enhanced with combined OOD detection using green ratio analysis and entropy-based rejection to prevent false predictions on non-plant images---a limitation discovered during testing when objects like keyboards were confidently misclassified as ``Disease'' with 89\% confidence.
    \item \textbf{ML Recommendation System:} Context-aware treatment recommendations were added, correlating ML predictions with current sensor readings to provide actionable guidance.
    \item \textbf{Multi-class Confidence Logging:} Extended logging to capture all class probabilities, not just the predicted class, improving diagnostic capabilities.
    \item \textbf{Threshold-based Alerting:} Automatic alert generation when predictions exceed 70\% confidence for non-healthy conditions.
    \item \textbf{Gallery Tab Redesign:} The Image Gallery was restructured from a simple image viewer to a side-by-side layout with the captured image (60\%) and a scrollable ML recommendations panel (40\%), improving usability on the 480$\times$320 touchscreen.
    \item \textbf{Acknowledge Recommendation Feature:} Added an ``Acknowledge'' button in the Gallery tab allowing users to mark recommendations as reviewed, updating the \texttt{user\_acknowledged} field in the database.
    \item \textbf{Touch-Optimized Navigation:} Gallery navigation arrows were changed from text characters (\texttt{<} \texttt{>}) to Unicode symbols ($\blacktriangleleft$ $\blacktriangleright$) for improved touch target visibility.
\end{itemize}

\setlength{\parindent}{0pt}
\hspace{1cm}{\textit{These modifications represent the iterative nature of embedded systems development, where testing on the target hardware reveals requirements not apparent during the design phase.}}

\section{Operating System Configuration (Buildroot)}

\setlength{\parindent}{0pt}
\hspace{1cm}{The foundation of the device is a custom-engineered Linux image (\texttt{sdcard.img}), configured to minimize overhead while maximizing hardware control. The configuration was managed via \texttt{make menuconfig} and saved to the \texttt{.config} file.}

\subsection{Target Architecture \& Toolchain}

\setlength{\parindent}{0pt}
\hspace{1cm}{The build was configured to leverage the full capabilities of the BCM2711 SoC.}

\begin{itemize}
    \item \textbf{Target Architecture:} AArch64 (ARM 64-bit)
    \item \textbf{Target CPU:} Cortex-A72
    \begin{itemize}
        \item Selecting the specific Cortex-A72 core ensures the compiler (GCC 14.3.0) utilizes the ARMv8-A instruction set extensions (NEON) critical for image processing performance.
    \end{itemize}
    \item \textbf{C Library:} glibc (GNU C Library)
    \begin{itemize}
        \item While musl is lighter, glibc was mandatory to ensure binary compatibility with the pre-compiled ONNX Runtime shared libraries used for AI inference.
    \end{itemize}
\end{itemize}

\subsection{System Initialization (Init System)}

\begin{itemize}
    \item \textbf{BusyBox Init:} The \texttt{BR2\_INIT\_BUSYBOX=y} option was selected.
    \begin{itemize}
        \item LeafSense uses BusyBox init with eudev for device management, providing a lightweight initialization system suitable for embedded applications. The startup script \texttt{S99leafsense} handles the application launch sequence.
    \end{itemize}
\end{itemize}

\subsection{Activated Package Ecosystem}

\setlength{\parindent}{0pt}
\hspace{1cm}{The following software stack was explicitly activated in the OS image to support the application requirements.}

\subsubsection{Graphical User Interface (Qt5)}

\begin{itemize}
    \item \texttt{BR2\_PACKAGE\_QT5=y}: Enables the Qt5 framework
    \item \texttt{BR2\_PACKAGE\_QT5BASE\_LINUXFB=y}: Configures Qt to render directly to the Linux Framebuffer
    \begin{itemize}
        \item This avoids the overhead of a Window Manager (X11/Wayland), allowing the GUI to run in ``Kiosk Mode'' with minimal RAM usage.
    \end{itemize}
    \item \texttt{BR2\_PACKAGE\_QT5BASE\_WIDGETS=y}: Enables standard UI elements (Buttons, Labels) used in \texttt{src/application/gui}.
    \item \texttt{BR2\_PACKAGE\_QT5BASE\_PNG=y} / \texttt{JPEG=y}: Required to load assets like \texttt{logo\_leafsense.png} located in \texttt{resources/images}.
\end{itemize}

\subsubsection{Computer Vision (OpenCV)}

\begin{itemize}
    \item \texttt{BR2\_PACKAGE\_OPENCV4=y}: The core computer vision library
    \item \texttt{BR2\_PACKAGE\_OPENCV4\_WITH\_V4L=y}: Enables Video4Linux support for the RPi Camera
    \item \texttt{BR2\_PACKAGE\_OPENCV4\_LIB\_IMGCODECS=y}: Image encoding/decoding support (PNG, JPEG)
    \item \texttt{BR2\_PACKAGE\_OPENCV4\_LIB\_IMGPROC=y}: Image processing functions
\end{itemize}

\subsubsection{Hardware Interaction}

\begin{itemize}
    \item \texttt{BR2\_PACKAGE\_LIBGPIOD=y}: The modern C library for GPIO control (available for future actuator integration)
    \item \texttt{BR2\_PACKAGE\_I2C\_TOOLS=y}: Essential for debugging the ADC and RTC sensors on the I2C bus
    \item \texttt{BR2\_PACKAGE\_RPI\_FIRMWARE=y}: Contains the bootloader and GPU binaries required for the Pi 4
\end{itemize}

\subsubsection{Connectivity \& Maintenance}

\begin{itemize}
    \item \texttt{BR2\_PACKAGE\_DROPBEAR=y}: Enables lightweight SSH server for secure remote access (smaller footprint than OpenSSH)
    \item \texttt{BR2\_PACKAGE\_WPA\_SUPPLICANT=y}: Handles Wi-Fi connections
    \item \texttt{BR2\_PACKAGE\_DHCPCD=y}: Manages IP address assignment
    \item \texttt{BR2\_PACKAGE\_PYTHON3=y} \& \texttt{BR2\_PACKAGE\_PYTHON\_PIP=y}: Included to support auxiliary scripts (\texttt{ml/train\_model.py}) and potential future expansions
\end{itemize}

\section{Software Architecture (C++ Implementation)}

\setlength{\parindent}{0pt}
\hspace{1cm}{The application logic was implemented in C++ to ensure deterministic runtime behavior and thread safety. The source code is organized into a modular hierarchy as evidenced by the project structure.}

\subsection{Project Structure}

\setlength{\parindent}{0pt}
\hspace{1cm}{The project utilizes CMake (\texttt{CMakeLists.txt}) for build automation and the code is separated into logical layers:}

\begin{itemize}
    \item \texttt{src/application}: Contains the high-level logic
    \begin{itemize}
        \item \texttt{gui/}: Qt5 widget implementations (e.g., \texttt{mainwindow.cpp}, \texttt{health\_display.cpp})
        \item \texttt{ml/}: The Machine Learning inference wrapper (\texttt{ML.cpp})
    \end{itemize}
    \item \texttt{src/drivers}: The Hardware Abstraction Layer (HAL)
    \begin{itemize}
        \item \texttt{actuators/}: Controls physical outputs (\texttt{Heater.cpp}, \texttt{Pumps.cpp}, \texttt{AlertLed.cpp})
        \item \texttt{sensors/}: Reads physical inputs (\texttt{ADC.cpp}, \texttt{Cam.cpp}, \texttt{PH.cpp}, \texttt{Sensor.cpp}, \texttt{TDS.cpp}, \texttt{Temp.cpp})
    \end{itemize}
    \item \texttt{src/middleware}: Business logic and orchestration (\texttt{Master.cpp}, \texttt{dbManager.cpp}, \\ \texttt{MQueueHandler.cpp}, \texttt{dDatabase.cpp}, \texttt{IdealConditions.cpp})
\end{itemize}

% [IMAGE PLACEHOLDER: Project directory structure diagram]
% Suggestion: Include a screenshot or diagram showing the complete project
% folder structure with annotations for each layer.

\subsection{Hardware Abstraction Layer (HAL)}

\setlength{\parindent}{0pt}
\hspace{1cm}{Located in \texttt{src/drivers}, this layer isolates the application from hardware specifics.}

\subsubsection{Sensors}

\setlength{\parindent}{0pt}
\hspace{1cm}{The sensor drivers provide a unified interface for reading environmental data:}

\begin{itemize}
    \item \textbf{ADC.cpp:} I2C driver for the ADS1115 16-bit ADC at address 0x48. Polls the conversion-ready bit for non-blocking operation.
    \item \textbf{PH.cpp:} Reads pH values from ADC channel 0 with two-point calibration support.
    \item \textbf{TDS.cpp:} Reads EC/TDS values from ADC channel 1 with temperature compensation.
    \item \textbf{Temp.cpp:} Reads DS18B20 temperature sensor via the 1-Wire sysfs interface.
    \item \textbf{Cam.cpp:} Captures images from the OV5647 camera using OpenCV's V4L2 backend.
\end{itemize}

\subsubsection{Actuators}

\setlength{\parindent}{0pt}
\hspace{1cm}{The actuator drivers provide GPIO-based control for physical outputs:}

\begin{itemize}
    \item \textbf{Pumps.cpp:} Controls three peristaltic pumps (pH Up on GPIO 6, pH Down on GPIO 13, Nutrient on GPIO 5) with configurable pulse duration.
    \item \textbf{Heater.cpp:} Controls the water heater relay on GPIO 26 with hysteresis to prevent oscillation.
    \item \textbf{AlertLed.cpp:} Interfaces with the kernel module at \texttt{/dev/led0} for visual alert notifications.
\end{itemize}

\subsection{Middleware \& Orchestration}

\setlength{\parindent}{0pt}
\hspace{1cm}{The Middleware layer (\texttt{src/middleware}) serves as the system's central nervous system.}

\begin{itemize}
    \item \textbf{Master Controller:} The \texttt{Master.cpp} class initializes the thread pool. It spawns worker threads for sensor reading (\texttt{tReadSensors}) and actuation, using POSIX Mutexes and Condition Variables to synchronize access to shared data.
    \item \textbf{Data Persistence:} The \texttt{dbManager.cpp} handles SQLite interactions. It creates the \texttt{leafsense.db} file in the application directory (\texttt{/opt/leafsense/}). The schema originates from \texttt{database/schema.sql} and is deployed to \texttt{/opt/leafsense/database/schema.sql}. Sensor readings are logged asynchronously via the \\ \texttt{MQueueHandler.cpp}, ensuring the GUI never freezes during disk writes.

\end{itemize}

% [IMAGE PLACEHOLDER: Middleware architecture diagram]
% Suggestion: Include a diagram showing the relationship between Master,
% MQueueHandler, dbManager, and the thread pool.

\section{AI Integration: C++ ONNX Runtime}

\setlength{\parindent}{0pt}
\hspace{1cm}{A significant engineering challenge was integrating the AI Inference Engine directly into the C++ environment without relying on Python wrappers.}

\begin{itemize}
    \item \textbf{Library Integration:} The system links against the ONNX Runtime C++ API. The pre-compiled libraries for AArch64 were placed in \texttt{external/onnxruntime-arm64/lib} and headers in \texttt{external/onnxruntime-arm64/include}.
    \item \textbf{Inference Logic:} The \texttt{src/application/ml/ML.cpp} class loads the \texttt{ml/leafsense\_model.onnx}. It converts the OpenCV \texttt{cv::Mat} image data into the specific Tensor format required by the model, executes the inference, and interprets the output logits to detect diseases or deficiencies.
\end{itemize}

% [IMAGE PLACEHOLDER: ONNX Runtime integration diagram]
% Suggestion: Include the ONNX Runtime logo and a flowchart showing the
% inference pipeline from image capture to classification result.

\subsection{Model Performance}

\setlength{\parindent}{0pt}
\hspace{1cm}{Table~\ref{tab:ml-performance} summarizes the machine learning model performance on the Raspberry Pi 4.}

\begin{table}[h!]
    \begin{center}
        \caption{ML Model Performance on Raspberry Pi 4}
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Metric} & \textbf{Value} \\
            \hline
            Model Architecture & MobileNetV3-Small \\
            \hline
            Model Size (ONNX) & 5.9 MB \\
            \hline
            Input Resolution & 224×224×3 (RGB) \\
            \hline
            Output Classes & 4 \\
            \hline
            Inference Time & ~150 ms \\
            \hline
            RAM Usage & ~50 MB \\
            \hline
            CPU Usage & ~80\% (1 core) \\
            \hline
            Accuracy & 99.39\% \\
            \hline
        \end{tabular}
        \label{tab:ml-performance}
    \end{center}
\end{table}

\subsection{Out-of-Distribution Detection}

\setlength{\parindent}{0pt}
\hspace{1cm}{A critical limitation of classification models is their tendency to predict one of the trained classes even for completely unrelated inputs. Testing revealed that a keyboard was confidently classified as ``Disease'' with 89\% confidence. To address this, the system implements \textbf{combined OOD detection} using both color analysis and entropy metrics.}

\subsubsection{Green Ratio Pre-filter}

\setlength{\parindent}{0pt}
\hspace{1cm}{The first stage analyzes the image in HSV color space to detect plant-like pixels. Green pixels are counted using two hue ranges: true green (35-85°) and yellow-green (20-35°). Images with less than 5\% green pixels are immediately rejected.}

\begin{lstlisting}[language=C++, caption={Green Ratio Calculation}]
float ML::checkGreenRatio(const cv::Mat& img) {
    cv::Mat hsv, greenMask, yellowGreenMask, combinedMask;
    cv::cvtColor(img, hsv, cv::COLOR_BGR2HSV);
    
    // True green (35-85 hue), yellow-green (20-35 hue)
    cv::inRange(hsv, cv::Scalar(35,30,30), cv::Scalar(85,255,255), greenMask);
    cv::inRange(hsv, cv::Scalar(20,30,30), cv::Scalar(35,255,255), yellowGreenMask);
    cv::bitwise_or(greenMask, yellowGreenMask, combinedMask);
    
    return (float)cv::countNonZero(combinedMask) / (img.rows * img.cols);
}
\end{lstlisting}

\subsubsection{Shannon Entropy Calculation}

\setlength{\parindent}{0pt}
\hspace{1cm}{After softmax normalization, the Shannon entropy of the probability distribution is calculated:}

\begin{equation}
H = -\sum_{i=1}^{N} p_i \log_2(p_i)
\end{equation}

\setlength{\parindent}{0pt}
\hspace{1cm}{For 4 classes, maximum entropy (uniform distribution) is $\log_2(4) = 2.0$. A well-trained model on valid inputs typically produces entropy $< 1.0$.}

\subsubsection{Rejection Criteria}

\setlength{\parindent}{0pt}
\hspace{1cm}{An image is classified as ``Unknown (Not a Plant)'' if any condition is met:}

\begin{itemize}
    \item \textbf{Low Green Ratio:} Less than 5\% green pixels (rejects non-plant objects)
    \item \textbf{High Entropy:} $H > 1.8$ (model is uncertain, probabilities spread across classes)
    \item \textbf{Low Confidence:} Maximum probability $< 30\%$
\end{itemize}

\begin{table}[h!]
    \begin{center}
        \caption{OOD Detection Thresholds (v1.5.6)}
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Threshold} & \textbf{Value} & \textbf{Meaning} \\
            \hline
            MIN\_GREEN\_RATIO & 0.10 (10\%) & Minimum green pixels (lettuce) \\
            \hline
            ENTROPY\_THRESHOLD & 1.8 & Max allowed entropy (out of 2.0) \\
            \hline
            MIN\_CONFIDENCE & 0.3 (30\%) & Minimum top-class probability \\
            \hline
        \end{tabular}
        \label{tab:ood-thresholds}
    \end{center}
\end{table}

\subsubsection{Implementation}

\begin{lstlisting}[language=C++, caption={Combined OOD Detection}]
bool ML::checkValidPlant(float entropy, float confidence, float greenRatio) {
    if (greenRatio < MIN_GREEN_RATIO) return false;   // 0.10 (10%)
    if (entropy > ENTROPY_THRESHOLD) return false;    // 1.8
    if (confidence < MIN_CONFIDENCE) return false;    // 0.3
    return true;
}
\end{lstlisting}

\subsection{Recommendation Generation}

\setlength{\parindent}{0pt}
\hspace{1cm}{Upon detecting a plant health issue, the system generates context-aware treatment recommendations by correlating ML predictions with current sensor readings.}

\begin{itemize}
    \item \textbf{Disease Detection:} Recommends treatment based on confidence level and disease type
    \item \textbf{Nutrient Deficiency:} Analyzes current EC reading to provide specific nutrient advice
    \item \textbf{Pest Damage:} Suggests organic pest control measures
    \item \textbf{pH Correlation:} Identifies potential nutrient lockout conditions
\end{itemize}

\setlength{\parindent}{0pt}
\hspace{1cm}{Recommendations are stored in the database and displayed in the application logs for operator review.}

\section{Deployment \& System Hardening}

\setlength{\parindent}{0pt}
\hspace{1cm}{Post-compilation, the system required specific configuration to become operational on the target device.}

\subsection{Storage Expansion}

\setlength{\parindent}{0pt}
\hspace{1cm}{The Buildroot configuration defines a minimal filesystem size ($\approx$289MB) to ensure fast flashing. To utilize the 32GB SD card capacity for database storage (\texttt{/opt/leafsense/leafsense.db}) and image logs:}

\begin{itemize}
    \item \textbf{Action:} The \texttt{resize2fs} utility (compiled on the host) was used to expand the root partition to fill the physical media.
    \item \textbf{Verification:} \texttt{df -h} on the target confirms ($\approx$29GB) of available space.
\end{itemize}

\subsection{Network Bridge (Provisioning)}

\setlength{\parindent}{0pt}
\hspace{1cm}{To facilitate the transfer of the compiled binaries and models via SCP, a NAT Bridge was established.}

\begin{itemize}
    \item \textbf{Host (Ubuntu):} Configured \texttt{iptables} to mask traffic from the USB-Ethernet interface.
    \item \textbf{Target (RPi):} Configured a static route (\texttt{route add default gw}) to the host.
    \item \textbf{Result:} This allowed the RPi to access NTP servers for time synchronization (\texttt{date -s}) and download any missing runtime dependencies.
\end{itemize}

\subsection{SSH Hardening}

\setlength{\parindent}{0pt}
\hspace{1cm}{The root account is configured with the password ``leafsense'' (\texttt{BR2\_TARGET\_GENERIC\_ROOT\_PASSWD}) for deployment access.

\begin{itemize}
    \item \textbf{Configuration:} Dropbear SSH is used instead of OpenSSH for its smaller footprint. Root login is enabled to facilitate deployment of the LeafSense binary and resources to \texttt{/opt/leafsense/}.
    \item \textbf{Production Note:} For production deployments, the password should be changed or replaced with SSH key-based authentication.
\end{itemize}}

\subsection{Remote Debugging \& Logging}

\setlength{\parindent}{0pt}
\hspace{1cm}{During development, the application logs can be viewed remotely via SSH. The following command starts the application and displays real-time diagnostic output including sensor readings, ML predictions, database operations, and GUI events:}

\begin{lstlisting}[caption={Remote Log Viewing Command}, label={lst:remote-logs}, language=bash]
sshpass -p leafsense ssh root@10.42.0.196 \
  'export QT_QPA_PLATFORM="linuxfb:fb=/dev/fb1" && \
   export QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS="/dev/input/event0:rotate=180:invertx" && \
   export QT_QPA_FB_NO_LIBINPUT=1 && \
   cd /opt/leafsense && ./LeafSense'
\end{lstlisting}

\hspace{1cm}{This command streams the application output to the terminal, providing visibility into:}
\begin{itemize}
    \item \textbf{Sensor readings:} Temperature, pH, and EC values with timestamps
    \item \textbf{ML inference:} Model predictions with confidence scores and OOD detection results
    \item \textbf{Database operations:} Insert confirmations for sensor data, images, and predictions
    \item \textbf{GUI events:} Theme changes, gallery navigation, and user interactions
\end{itemize}

\subsection{Final File Structure}

\setlength{\parindent}{0pt}
\hspace{1cm}{The deployed system follows the structure shown in Listing~\ref{lst:file-structure}.\\}

\begin{lstlisting}[caption={Raspberry Pi 4 File Structure}, label={lst:file-structure}, basicstyle=\ttfamily\small]
Raspberry Pi 4B
|-- /opt/leafsense/
|   |-- LeafSense                      # Application binary (~850 KB)
|   |-- leafsense_model.onnx           # ML Model (5.9 MB)
|   |-- leafsense_model_classes.txt    # Class labels file
|   |-- leafsense.db                   # SQLite Database
|   |-- schema.sql                     # SQL Schema
|   |-- start.sh                       # Startup script
|   `-- gallery/                       # Captured plant images
|-- /usr/lib/
|   |-- libonnxruntime.so*             # ONNX Runtime (16 MB)
|   `-- libQt5Charts.so*               # Qt5Charts (1.9 MB)
|-- /root/
|   `-- led.ko                         # LED kernel module (13 KB)
`-- /var/log/
    `-- messages                       # System logs (includes LeafSense output)
\end{lstlisting}

\section{Kernel Module Development}

\setlength{\parindent}{0pt}
\hspace{1cm}{A Linux kernel module was developed for controlling an indicator LED via GPIO. The module implements a character device driver that exposes the device \texttt{/dev/led0}.}

\subsection{Main Characteristics}

\begin{itemize}
    \item Direct access to BCM2837 GPIO registers via \texttt{ioremap}
    \item GPIO base address: \texttt{0xFE200000} (BCM2711/Raspberry Pi 4)
    \item GPIO used: Pin 20
    \item Supported operations: \texttt{open}, \texttt{close}, \texttt{read}, \texttt{write}
\end{itemize}

\subsection{Code Structure}

\setlength{\parindent}{0pt}
\hspace{1cm}{The kernel module implements direct register access as shown in Listing~\ref{lst:gpio-registers}.\\}

\begin{lstlisting}[language=C, caption={GPIO Register Definitions (utils.h)}, label={lst:gpio-registers}]
// Hardware Base Addresses
#define BCM2708_PERI_BASE  0x3f000000  // RPi 3 (use 0xFE000000 for RPi 4)
#define GPIO_BASE   (BCM2708_PERI_BASE + 0x200000)

// GPIO Register Structure
struct GpioRegisters {
    uint32_t GPFSEL[6];  // Function Select registers
    uint32_t Reserved1;
    uint32_t GPSET[2];   // Pin Output Set registers
    uint32_t Reserved2;
    uint32_t GPCLR[2];   // Pin Output Clear registers
};

// Map registers to virtual memory (in ledmodule.c)
s_pGpioRegisters = (struct GpioRegisters *)ioremap(GPIO_BASE, 
                                    sizeof(struct GpioRegisters));

// Configure GPIO 20 as output and control LED
SetGPIOFunction(s_pGpioRegisters, LedGpioPin, 0b001);
SetGPIOOutputValue(s_pGpioRegisters, LedGpioPin, outputValue);
\end{lstlisting}

\textbf{Technical Note:} The \texttt{ioremap\_nocache} function was replaced with \texttt{ioremap} due to changes in the Linux kernel 5.6+ API.

\subsection{Module Compilation}

\setlength{\parindent}{0pt}
\hspace{1cm}{Module compilation requires the kernel headers from Buildroot:
\\}

\begin{lstlisting}[language=bash, caption={Kernel Module Compilation}]
cd drivers/kernel_module/
# Environment variables are set in Makefile:
# KDIR=/path/to/buildroot/output/build/linux-custom
# CROSS_COMPILE=/path/to/buildroot/output/host/bin/aarch64-linux-
# ARCH=arm64
make
\end{lstlisting}

% [IMAGE PLACEHOLDER: LED module test photograph]
% Suggestion: Include a photo showing the LED connected to GPIO 20 in both
% ON and OFF states, demonstrating the kernel module functionality.

\section{Graphical User Interface}

\setlength{\parindent}{0pt}
\hspace{1cm}{The LeafSense system incorporates a comprehensive Graphical User Interface (GUI) as a central part of its user experience. The GUI serves as the primary interaction layer, transforming raw hydroponic sensor data into visual insights and operational controls.}

\subsection{Design Philosophy}

\setlength{\parindent}{0pt}
\hspace{1cm}{The GUI was developed to ensure intuitive access and clear navigation throughout the application regardless of the user's technical background. Its design prioritizes readability and visual hierarchy, allowing users to quickly assess plant health, diagnose issues, or make system changes without needing to interpret complex data formats or use command-line tools.}

\setlength{\parindent}{0pt}
\hspace{1cm}{A distinctive element of the LeafSense GUI is its support for both light and dark modes:}

\begin{itemize}
    \item \textbf{Light Mode:} Generally preferred in bright environments, providing high visibility and minimizing eye strain during daytime usage.
    \item \textbf{Dark Mode:} Optimized for low-light conditions or users working for extended periods, reducing glare and supporting comfortable prolonged system monitoring.
\end{itemize}

\subsection{Application Windows}

\setlength{\parindent}{0pt}
\hspace{1cm}{The application is organized into several focused windows, each designed to perform a specific role within the LeafSense ecosystem:}

\subsubsection{Login Window}

\setlength{\parindent}{0pt}
\hspace{1cm}{This is the entry point to LeafSense, where users authenticate before accessing the system. The window is visually minimal and distraction-free, with no title bar or control buttons, ensuring the user's attention is solely directed towards secure access.}

% [IMAGE PLACEHOLDER: Login Window screenshots]
% Suggestion: Include side-by-side screenshots showing the Login Window
% in both Light Mode and Dark Mode.

\subsubsection{Main Window (Dashboard)}

\setlength{\parindent}{0pt}
\hspace{1cm}{After successful login, the user is presented with the main dashboard. This window aggregates real-time sensor data (such as pH, temperature, and EC levels), and current plant health assessment. It provides navigation buttons for logs, settings, info, and logout.}

% [IMAGE PLACEHOLDER: Main Dashboard screenshots]
% Suggestion: Include side-by-side screenshots showing the Dashboard
% in both Light Mode and Dark Mode, with annotations highlighting key elements.

\subsubsection{Logs Window}

\setlength{\parindent}{0pt}
\hspace{1cm}{The logs window offers a filterable view into system alerts, plant disease records, nutrient deficiency events, and maintenance history. The user can easily switch log categories using prominent filter buttons at the top.}

% [IMAGE PLACEHOLDER: Logs Window screenshots]
% Suggestion: Include screenshots showing each tab (Alerts, Diseases,
% Deficiencies, Maintenance) in both themes.

\subsubsection{Settings Window}

\setlength{\parindent}{0pt}
\hspace{1cm}{The settings window allows the user to configure system preferences, most notably changing the ideal sensor parameters and toggling between light and dark mode.}

% [IMAGE PLACEHOLDER: Settings Window screenshots]
% Suggestion: Include side-by-side screenshots showing the Settings Window
% with the threshold adjustment controls visible.

\subsubsection{Analytics Window}

\setlength{\parindent}{0pt}
\hspace{1cm}{The analytics window provides historical data visualization and analysis capabilities. It features three main tabs:}

\begin{itemize}
    \item \textbf{Sensor Readings Table:} Displays historical sensor data in tabular format
    \item \textbf{Trends Chart:} Visualizes sensor trends over time using Qt Charts
    \item \textbf{Image Gallery:} Browsable gallery of captured plant images with ML recommendations panel, allowing users to view predictions and acknowledge recommendations
\end{itemize}

% [IMAGE PLACEHOLDER: Analytics Window screenshots]
% Suggestion: Include screenshots showing each tab (Sensor Table, Trends Chart,
% Image Gallery) in both light and dark mode.

\subsubsection{Info Window}

\setlength{\parindent}{0pt}
\hspace{1cm}{Accessible from the dashboard, this window displays relevant static and session information, such as username and login timestamp.}

% [IMAGE PLACEHOLDER: Info Window screenshots]
% Suggestion: Include side-by-side screenshots showing the Info Window.

\subsubsection{Dialog Popups}

\setlength{\parindent}{0pt}
\hspace{1cm}{Dialog windows are used for critical interactions such as confirming user logout. Popups display information and action buttons (e.g., ``Yes'' and ``No'') with colors and alignment that conform to the app's overall theme.}

% [IMAGE PLACEHOLDER: Logout Confirmation Dialog screenshots]
% Suggestion: Include side-by-side screenshots showing the dialog popup.

\section{Sensor Integration}

\setlength{\parindent}{0pt}
\hspace{1cm}{The LeafSense system integrates multiple sensors via I2C and 1-Wire protocols. The sensor drivers are implemented in \texttt{src/drivers/sensors/}.}

\subsection{Temperature Sensor (DS18B20)}

\setlength{\parindent}{0pt}
\hspace{1cm}{The DS18B20 digital temperature sensor uses the 1-Wire protocol on GPIO 19. The Linux kernel's w1-gpio driver handles low-level communication, exposing temperature readings via sysfs:}

\begin{lstlisting}[language=bash, caption={Reading DS18B20 temperature}]
# Read raw temperature (millidegrees Celsius)
cat /sys/bus/w1/devices/28-*/temperature
# Example output: 23562 (= 23.562 degrees C)
\end{lstlisting}

\subsection{Analog Sensors (pH and TDS)}

\setlength{\parindent}{0pt}
\hspace{1cm}{Analog sensors are read via the ADS1115 16-bit ADC at I2C address 0x48. The ADC driver (\texttt{ADC.cpp}) polls the conversion-ready bit to ensure accurate readings without blocking delays:}

\begin{itemize}
    \item \textbf{pH Sensor (PH-4502C):} Connected to ADC channel 0. Calibrated with known pH buffer solutions.
    \item \textbf{TDS Sensor (Grove):} Connected to ADC channel 1. Converts voltage to ppm using temperature compensation.
\end{itemize}

\subsection{Camera (OV5647)}

\setlength{\parindent}{0pt}
\hspace{1cm}{The 5MP OV5647 camera module interfaces via CSI. Image capture uses OpenCV's V4L2 backend (\texttt{Cam.cpp}), with images resized to 224×224 for ML inference.}

\section{Actuator Integration}

\setlength{\parindent}{0pt}
\hspace{1cm}{Actuators are controlled via GPIO using libgpiod. The actuator drivers are implemented in \texttt{src/drivers/actuators/}.}

\subsection{Peristaltic Pumps}

\setlength{\parindent}{0pt}
\hspace{1cm}{Three peristaltic pumps provide precise fluid dosing:}

\begin{itemize}
    \item \textbf{pH Up Pump:} GPIO 6 -- Dispenses alkaline solution when pH is below target
    \item \textbf{pH Down Pump:} GPIO 13 -- Dispenses acidic solution when pH is above target
    \item \textbf{Nutrient Pump:} GPIO 5 -- Dispenses nutrient concentrate when EC is low
\end{itemize}

\setlength{\parindent}{0pt}
\hspace{1cm}{The \texttt{Pumps.cpp} driver implements timed activation pulses with configurable duration for precise dosing control.}

\subsection{Water Heater}

\setlength{\parindent}{0pt}
\hspace{1cm}{A 220V submersible heater is controlled via relay on GPIO 26. The \texttt{Heater.cpp} driver implements hysteresis control to prevent oscillation, activating when temperature drops below the lower threshold and deactivating when it reaches the upper threshold.}

\subsection{Alert LED}

\setlength{\parindent}{0pt}
\hspace{1cm}{The alert LED on GPIO 20 is controlled via a custom kernel module (\texttt{/dev/led0}). The \texttt{AlertLed.cpp} driver provides a high-level interface for alert notifications.}

% System validation and test results are documented in the Results chapter
% Difficulties and Solutions have been moved to the Conclusion chapter

\section{Possible Future Enhancements}

\setlength{\parindent}{0pt}
\hspace{1cm}{The following features represent potential enhancements for future versions of LeafSense:}

\begin{enumerate}
    \item \textbf{Object Detection Model} -- Upgrade from image classification to YOLO-based object detection to enable bounding boxes around diseased leaf areas, providing more precise localization of plant health issues.
    \item \textbf{Automated Startup} -- Configure an init script (S99leafsense) for automatic application launch on system boot without manual intervention.
    \item \textbf{NTP Synchronization} -- Implement proper network time synchronization for accurate timestamps across sensor readings and ML predictions.
    \item \textbf{Data Export} -- Allow CSV/JSON export of sensor history and ML predictions for offline analysis and reporting.
    \item \textbf{Web Server} -- Enable remote access via browser interface for monitoring without physical access to the device.
    \item \textbf{Push Notifications} -- Implement alerts via Telegram/Email for critical plant health conditions.
    \item \textbf{Mobile Dashboard} -- Develop Android/iOS companion application for remote monitoring and control.
    \item \textbf{Multi-plant Support} -- Extend database schema and GUI to monitor multiple plants simultaneously.
    \item \textbf{Cloud Backup} -- Implement optional cloud synchronization for data backup and remote access.
\end{enumerate}